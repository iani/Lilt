	/* IZ 2007-01-24 { (SC3)
This script sets the standard start and stop variables for creating a session.
It is used as an include by all files that are generated by Session in order to 
save and reload a session. 

THIS FILE SHOULD NOT BE REMOVED, MOVED, CHANGED OR RENAMED.

} */

// Load the samples required by this Session: 
var serverSamples;
serverSamples = Samples(~server);
~samples = ~samplePaths collect: serverSamples.loadIfNotPresent(_);

// Make this script be loaded inside the group "Session Making Scripts" 
// of Session "Session Makers":
~script.session = Session named: 'Session Makers';
~script.scriptGroup = ~script.session scriptGroupNamed: 'Session Making Scripts';

// On start, create Session, Script groups and Scripts; link Scripts, 
// set their MIDI bindings and load their parameter snapshots: 
~start = {
	var session, linkDict, groupName, scriptName, script, sessionScript;
	var scriptData, scriptDataLib;
	Post << "Loading session: " << ~sessionName << " ...\n";
	~session = session = Session(~sessionName.asSymbol, ~server, 3,  nil, ~script.path, ~samples);
	session.script = sessionScript = ~script;	// store script that created this session 
	session.addDependant({ | who, how | // inform script when this session closes
		if (how == \closed) { sessionScript.stopped; };
	});
	// create script groups and scripts
	linkDict = Library.new;
	~scriptGroups do: { | sg |
		groupName = sg[0].asSymbol;
		session.addScriptGroup(groupName);
		sg[1..] do: { | spec |
			script = Script.loadFromBrowser(*spec);
			linkDict[groupName, script.name.asSymbol] = script;
		}
	};
	// link any scripts whose signal i/o is connected
	~linkSpecs do: { | spec |
		linkDict.atPath(spec[..1]).parameterEnvir[spec[2]]
			addReader: linkDict.atPath(spec[[3,4]]).parameterEnvir[spec[5]];
	};
	// Add saved MIDI bindings to each script
	~midiBindings do: { | spec |
		linkDict.atPath(spec[..1]).midiBindings = spec[2..];
	};
	// Load saved snapshots to each script
	~snapshots do: { | spec |
		(script = linkDict.atPath(spec[..1])).snapshots.list = spec[2..]
			collect: Snapshot.fromScriptData(script, *_);
		script.loadInitSnapshot; // load any snapshots named init
	};
	// Below: Put Script-specific data in library for access by Script-group and Script name
	// Script-specific data are data beyond the standard types above (links, midi, snapshots)
	// They are written by method Script:saveData which saves anything specified by 
	// a function in ~saveData variable in a Scripts environment, if present.
	// TODO: possibly all of links, Scripts, MIDI-bindings, snapshots and Script-data
	// could be saved under a single library in the environment of the Session's script
	// and therefore be uniformly available to all Scripts of a Session.
	scriptData = ~scriptData;
//	scriptData.postln;
//	"these were the script data of the session".postln;
	scriptData do: { | d |
		linkDict.atPath(d[..1]) loadData: d[2..];
		// .scriptData = d[2..];
	};
//	scriptDataLib = Library.new;
//	scriptData do: { | d | scriptDataLib.putAtPath(d[..1], d[2..]) };
//	~scriptData = scriptDataLib;
//	session.scriptData = scriptDataLib;
//	thisMethod.report(session, session.scriptData, scriptDataLib);
	Post << "... Session Loaded\n";
	// Remove this script from Sessions when its window closes: 
	sessionScript.removeWhenGuiCloses;
	// Inform any Script or other object that needs to do stuff after loading is done:
	session.changed(\loaded);
	Session.select(session.name);
};

// On stop, close all scripts, and remove the session:
~stop = {
	Post << "Removing session: " << ~sessionName << " ... ";
	~session.close;
	~session.remove;
	Post << "done\n";
//	~script.release;
};

// Start the script to actually create the session as soon as this session script is loaded:
~script doWhenInited: { | script |
	script.guiBounds.top = 0;
	script.start;
};
