
// Tones
a = Tone.new;
a.freq;
a.play;

b = Tone(-1, 1);
b.freq;
b.play;


c = Tone(-1);
c.freq;
c.play;

================================

// Chords

a = Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]);
a.reference_tone;
a.consonance_grade;
a.play;

b = Chord(*3 + [[-2, 0, 0, 0], [0, 0, -1, 0], [-1, -1, 0, 0], [-3, 0, 0, 0]]);
b.reference_tone;
b.consonance_grade;
b.play;

c = Chord([0, 0, 1, 0], [2, 0, 0, 0], [0, -1, 1, 0], [-1, 0, 1, 0]);
d = Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0]);
e = Chord([-2, 0, 0, 0], [0, 0, -1, 0], [-1, -1, 0, 0]);
f = Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]);
g = Chord([1, 0, 0, 0], [0, 1, 0, 0], [2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0]);

a.play;
b.play;
c.play;

p = [a, b, c, d, e, f, g];

r = Routine({
	p do: { | chord |
		chord.play;
		1.wait;	
	};
});

r.play;
r.stop;


Pbind(\freq, Pseq([440, 660], inf)).play


Event


a gs: Tone(3, -2);
e = 



Tone(5, 1, 1).gs / 4

Tone(6, 1, 1).gs / 4

Tone(4, 2, 1).gs / 5

Tone(3, -2).gs

Tone(1, 1, -1).gs

e = Array.iota(3, 4);
f = e.flop collect: _.largest;
g = e.flop collect: _.smallest;


f
g

e -.1 f;
(e -.1 g) *.-1;
g -.3 e;
g
f

Chord([0, 1, 2, 3], [3, 4, 5, 6], [2, 3, 4, 5]);
Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]);
Chord(*3 + [[-2, 0, 0, 0], [0, 0, -1, 0], [-1, -1, 0, 0], [-3, 0, 0, 0]]);
Chord([0, 0, 1, 0], [2, 0, 0, 0], [0, -1, 1, 0], [-1, 0, 1, 0]);


Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0]);
Chord([-2, 0, 0, 0], [0, 0, -1, 0], [-1, -1, 0, 0]);



Chord([2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]);
Chord([1, 0, 0, 0], [0, 1, 0, 0], [2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0]);

[ [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ], [ 3, 0, 0, 0 ] ] collect: { | v | product([2, 3, 5, 7] ** v) }
[ [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ], [ 3, 0, 0, 0 ] ] collect: product([2, 3, 5, 7] ** _) 


Chord([0, 0, 0, 0], [0, 1, 0, 0], [2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0]);


Chord([0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]);

[2, 3, 5, 7] ** [ [ 0, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ] ].flop.sum;



[ [ 2, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 1, 1, 0, 0 ], [ 3, 0, 0, 0 ] ].flop collect: _.largest



[2, 3, 5, 7] **.1 [[2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]];
[2, 3, 5, 7] collect: 


[[2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]] collect: ([2, 3, 5, 7] ** _);

([[2, 0, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [3, 0, 0, 0]] collect: ([2, 3, 5, 7] ** _));


